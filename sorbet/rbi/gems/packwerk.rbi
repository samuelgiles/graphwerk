# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/packwerk/all/packwerk.rbi
#
# packwerk-1.0.0

module Packwerk
end
module Packwerk::OutputStyles
end
class Packwerk::OutputStyles::Plain
  def self.error; end
  def self.filename; end
  def self.reset; end
end
class Packwerk::OutputStyles::Coloured
  def self.error; end
  def self.filename; end
  def self.reset; end
end
class Packwerk::Offense
  def file; end
  def initialize(*args, &blk); end
  def location; end
  def message; end
  def to_s(*args, &blk); end
  extend T::Helpers
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Package
  def <=>(other); end
  def dependencies; end
  def dependency?(package); end
  def enforce_dependencies?; end
  def enforce_privacy; end
  def initialize(name:, config:); end
  def name; end
  def package_path?(path); end
  def public_path; end
  def public_path?(path); end
  def root?; end
  def to_s; end
  include Comparable
end
class Packwerk::PackageSet
  def each(&blk); end
  def fetch(name); end
  def initialize(packages); end
  def package_from_path(file_path); end
  def self.create_root_package_if_none_in(packages); end
  def self.load_all_from(root_path, package_pathspec: nil); end
  def self.package_paths(root_path, package_pathspec); end
  include Enumerable
end
class Packwerk::Graph
  def acyclic?; end
  def add_cycle(cycle); end
  def cycles; end
  def initialize(*edges); end
  def neighbours(node); end
  def nodes; end
  def process; end
  def visit(node, visited_nodes: nil, path: nil); end
end
module Packwerk::Inflections
end
module Packwerk::Inflections::Default
  def self.apply_to(inflections_object); end
end
class Packwerk::Inflections::Custom
  def apply_to(inflections_object); end
  def inflections; end
  def inflections=(arg0); end
  def initialize(custom_inflection_file = nil); end
end
class Packwerk::Inflector
  def inflections(_ = nil); end
  def initialize(custom_inflection_file: nil); end
  def pluralize(word, count = nil); end
  def self.default; end
  include ActiveSupport::Inflector
end
class Packwerk::ApplicationValidator
  def check_acyclic_graph; end
  def check_all; end
  def check_application_structure; end
  def check_autoload_path_cache; end
  def check_inflection_file; end
  def check_package_manifest_paths; end
  def check_package_manifest_syntax; end
  def check_package_manifests_for_privacy; end
  def check_root_package_exist; end
  def check_valid_package_dependencies; end
  def format_yaml_strings(list); end
  def initialize(config_file_path:, application_load_paths:, configuration:); end
  def invalid_package_path?(path); end
  def package_glob; end
  def package_manifests(glob_pattern); end
  def package_manifests_settings_for(setting); end
  def relative_paths(paths); end
end
class Packwerk::ApplicationValidator::Result < Struct
  def error_value; end
  def error_value=(_); end
  def ok?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
module Packwerk::ConstantNameInspector
  def constant_name_from_node(*args, &blk); end
  extend T::Helpers
  extend T::InterfaceWrapper::Helpers
  extend T::Private::Abstract::Hooks
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
module Packwerk::Node
  def self.class_or_module_name(class_or_module_node); end
  def self.constant_name(constant_node); end
  def self.each_child(node); end
  def self.enclosing_namespace_path(starting_node, ancestors:); end
  def self.hash_pair_key(hash_pair_node); end
  def self.hash_pair_value(hash_pair_node); end
  def self.hash_pairs(hash_node); end
  def self.literal_value(string_or_symbol_node); end
  def self.location(node); end
  def self.method_arguments(method_call_node); end
  def self.method_call_node(block_node); end
  def self.method_name(method_call_node); end
  def self.module_creation?(node); end
  def self.module_name_from_definition(node); end
  def self.name_from_block_definition(node); end
  def self.name_location(node); end
  def self.name_part_from_definition(node); end
  def self.parent_class(class_node); end
  def self.parent_module_name(ancestors:); end
  def self.receiver(method_call_or_block_node); end
  def self.type(node); end
  def self.value_from_hash(hash_node, key); end
end
class Packwerk::Node::TypeError < ArgumentError
end
class Packwerk::Node::Location < Struct
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Packwerk::AssociationInspector
  def constant_name_from_node(node, ancestors:); end
  def initialize(inflector: nil, custom_associations: nil); end
  include Packwerk::ConstantNameInspector
end
class Packwerk::Reference < Struct
  def constant; end
  def constant=(_); end
  def relative_path; end
  def relative_path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source_package; end
  def source_package=(_); end
end
class Packwerk::ViolationType < T::Enum
end
module Packwerk::ReferenceLister
  def listed?(*args, &blk); end
  extend T::Helpers
  extend T::InterfaceWrapper::Helpers
  extend T::Private::Abstract::Hooks
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::CheckingDeprecatedReferences
  def deprecated_references_file_for(package); end
  def deprecated_references_for(source_package); end
  def initialize(root_path); end
  def listed?(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::ReferenceLister
end
class Packwerk::Configuration
  def all_application_autoload_paths; end
  def config_path; end
  def custom_associations; end
  def exclude; end
  def include; end
  def inflections_file; end
  def initialize(configs = nil, config_path: nil); end
  def load_paths; end
  def package_paths; end
  def root_path; end
  def self.from_packwerk_config(path); end
  def self.from_path(path = nil); end
end
class Packwerk::FilesForProcessing
  def configured_excluded_files; end
  def configured_included_files; end
  def custom_files; end
  def custom_included_files(path); end
  def files; end
  def files_for_globs(globs); end
  def initialize(paths, configuration); end
  def self.fetch(paths:, configuration:); end
end
module Packwerk::Formatters
end
class Packwerk::Formatters::ProgressFormatter
  def finished(execution_time); end
  def initialize(out, style: nil); end
  def mark_as_failed; end
  def mark_as_inspected; end
  def started(target_files); end
  def started_validation; end
end
class Packwerk::ConstantDiscovery
  def context_for(const_name, current_namespace_path: nil); end
  def initialize(constant_resolver:, packages:); end
  def package_from_path(path); end
end
class Packwerk::ConstantDiscovery::ConstantContext < Struct
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def package; end
  def package=(_); end
  def public?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Packwerk::ConstNodeInspector
  def constant_in_module_or_class_definition?(node, parent:); end
  def constant_name_from_node(node, ancestors:); end
  include Packwerk::ConstantNameInspector
end
class Packwerk::DependencyChecker
  def invalid_reference?(reference, reference_lister); end
  def message_for(reference); end
  def violation_type; end
end
module Packwerk::Parsers
end
class Packwerk::Parsers::ParseResult < Packwerk::Offense
end
class Packwerk::Parsers::ParseError < StandardError
  def initialize(result); end
  def result; end
end
class Packwerk::FileProcessor
  def call(file_path); end
  def initialize(run_context:, parser_factory: nil); end
end
class Packwerk::FileProcessor::UnknownFileTypeResult < Packwerk::Offense
  def initialize(file:); end
end
class Packwerk::NodeProcessor
  def call(node, ancestors:); end
  def check_reference(reference, node); end
  def failed_check(reference); end
  def initialize(reference_extractor:, reference_lister:, filename:, checkers:); end
end
class Packwerk::PrivacyChecker
  def enforcement_disabled?(privacy_option); end
  def explicitly_private_constant?(constant, explicitly_private_constants:); end
  def invalid_reference?(reference, reference_lister); end
  def message_for(reference); end
  def violation_type; end
end
class Packwerk::ParsedConstantDefinitions
  def add_definition(constant_name, current_namespace_path, location); end
  def collect_local_definitions_from_root(node, current_namespace_path = nil); end
  def initialize(root_node:); end
  def local_reference?(constant_name, location: nil, namespace_path: nil); end
  def self.reference_qualifications(constant_name, namespace_path:); end
end
class Packwerk::ReferenceExtractor
  def initialize(*args, &blk); end
  def local_reference?(constant_name, name_location, namespace_path); end
  def reference_from_constant(constant_name, node:, ancestors:, file_path:); end
  def reference_from_node(node, ancestors:, file_path:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::RunContext
  def checkers; end
  def constant_name_inspectors; end
  def context_provider; end
  def file_processor; end
  def initialize(root_path:, load_paths:, package_paths: nil, inflector: nil, custom_associations: nil, checker_classes: nil, node_processor_class: nil, reference_lister: nil); end
  def node_processor_class; end
  def node_processor_for(filename:, ast_node:); end
  def reference_lister; end
  def root_path; end
  def self.from_configuration(configuration, reference_lister: nil); end
end
class Packwerk::DeprecatedReferences
  def add_entries(reference, violation_type); end
  def deprecated_references; end
  def dump; end
  def initialize(package, filepath); end
  def listed?(*args, &blk); end
  def prepare_entries_for_dump; end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::ReferenceLister
end
class Packwerk::UpdatingDeprecatedReferences
  def deprecated_references_file_for(package); end
  def deprecated_references_for(package); end
  def dump_deprecated_references_files; end
  def initialize(root_path, deprecated_references = nil); end
  def listed?(*args, &blk); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
  include Packwerk::ReferenceLister
end
class Packwerk::Cli
  def check(paths); end
  def execute_command(*args, &blk); end
  def fetch_files_to_process(paths); end
  def generate_configs; end
  def init; end
  def initialize(run_context: nil, configuration: nil, out: nil, err_out: nil, style: nil); end
  def list_validation_errors(result); end
  def mark_progress(offenses); end
  def rails_app?(*args, &blk); end
  def run(*args, &blk); end
  def show_offenses(offenses); end
  def update(paths); end
  def validate(_paths); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
module Packwerk::Generators
end
class Packwerk::Generators::ApplicationValidation
  def generate(for_rails_app:); end
  def generate_packwerk_validate_script; end
  def generate_validation_test; end
  def initialize(root, out: nil); end
  def self.generate(for_rails_app: nil, root: nil, out: nil); end
end
class Packwerk::Generators::ConfigurationFile
  def generate(*args, &blk); end
  def initialize(*args, &blk); end
  def render; end
  def self.generate(load_paths:, root:, out:); end
  def set_template_variables; end
  def template; end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Generators::InflectionsFile
  def generate(*args, &blk); end
  def initialize(root, out: nil); end
  def self.generate(root:, out:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::Generators::RootPackage
  def generate(*args, &blk); end
  def initialize(root:, out: nil); end
  def self.generate(root:, out:); end
  extend T::Private::Methods::MethodHooks
  extend T::Private::Methods::SingletonMethodHooks
  extend T::Sig
end
class Packwerk::NodeVisitor
  def initialize(node_processor:); end
  def visit(node, ancestors:, result:); end
end
